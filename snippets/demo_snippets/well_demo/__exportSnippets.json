[
    {
        "name": "graph_to_table_serialization.js",
        "content": "function getTableFromGraph(targetLiveDash) {\n    const { graph } = JSON.parse(targetLiveDash.graphJSON);\n\n    const defaultProps = {};\n\n    graph.nodes.forEach(node => {\n        Object.keys(node.properties).forEach(key => {\n            defaultProps[key] = '';\n        })\n    })\n\n    const table = [];\n    const wideTable = [];\n\n    graph.nodes.forEach(node => {\n        const { primitiveID, properties } = node;\n        let line = {\n            measure: `measure_${primitiveID}`,\n            primitiveID,\n            ...defaultProps\n        }\n        Object.entries(properties).forEach(prop => {\n            const [propName, propData] = prop;\n\n            line[propName] = propData.value\n            table.push({\n                \"Node_property\":`${primitiveID}.${propName}`,\n                \"monitoring\": propData.value,\n            });\n        });\n\n        wideTable.push(line)\n    });\n    return [table, wideTable]\n}\n\n"
    },
    {
        "name": "remove_otl_properties.js",
        "content": "let liveDash = Application.autocomplete.LiveDashPanel_4\n\nfor (let node of liveDash.masterGraph.nodes) {\n    console.log(node)\n    for (let prop in node.tag.properties) {\n        let property = node.tag.properties[prop]\n        if (property.type === \"datasource\") {\n            console.log(property)\n            property.expression = \"\"\n            property.value = \"\"\n            property.status = \"complete\"\n            property.type = \"expression\"\n        }\n    }\n}\n"
    },
    {
        "name": "massive_property_expression_update.js",
        "content": "let liveDash = Application.autocomplete.LiveDashPanel_2\n\n// const addProps = {\n//   \"res_watercut_percent\": \"//res_watercut_percent\\n' '\",\n//   \"res_liquid_density_kg_m3\": \"//res_liquid_density_kg_m3\\n' '\",\n//   \"res_pump_power_watt\": \"//res_pump_power_watt\\n' '\",\n//   \"X_kg_sec\": \"//res_mass_flow_kg_sec\\n' '\",\n//   \"velocity_m_sec\": \"//res_velocity_m_sec\\n' '\"\n// };\n\n// const defExpr = {\n//   \"type\": \"expression\",\n//   \"expression\": \"\",\n//   \"status\": \"completed\",\n//   \"value\": \"\"\n// }\n\n// // creaate new props and fill annotation\n// liveDash.masterGraph.nodes.toArray().filter(\n//   node => {\n//     if (node.tag.properties?.object_type) {\n//       return (\n//         node.tag.properties['object_type'].value === \"pipe\" ||\n//         node.tag.properties['object_type'].value === \"junctionpoint\"\n//       )\n//     }\n//   }\n// ).map(node => {\n//   Object.entries(addProps).map(([p, info]) => {\n//     node.tag.properties[p] = defExpr;\n//     node.tag.properties[p].expression = \"\";\n//   })\n// })\n\nlet dataLakeNodes = liveDash.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})\n\nlet dlProps = dataLakeNodes.reduce((acc, dataLakeNode) => {\n  return {\n    ...acc,\n    [dataLakeNode.tag.primitiveID]: Object.entries(dataLakeNode.tag.properties)\n    .filter(p => !p[0].startsWith(\"_\") && p[0] !== \"query\")\n  }\n}, {})\n\nliveDash.masterGraph.nodes.forEach((node) => {\n  if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n  Object.keys(dlProps).forEach((dln) => {\n    dlProps[dln].forEach(([propertyName,propertyBody]) => {\n      if ( propertyName in node.tag.properties) {\n        node.tag.properties[propertyName]\n          .expression = `\n          +(${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.node_id})[0][${dln}.${propertyName}]) !== NaN ?\n          +(${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.node_id})[0][${dln}.${propertyName}]) :\n          ${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.node_id})[0][${dln}.${propertyName}]\n          `\n      }\n    })\n  })\n})\n\nliveDash.masterGraph.nodes.toArray().filter(\n    node => {\n        if (node.tag.properties?.object_type) {\n            return (node.tag.primitiveName === \"oil_well\")\n        }\n    }\n).forEach(node => node.tag.properties.Value.expression = \"this.LiquidDebit * this.LiquidDensity / 86400\")\n\nconsole.log(\"added link to datalake nodes\");"
    },
    {
        "name": "from_monitoring_to_whatIf.js",
        "content": "let customActionTitle = \"Switch to WhatIf\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\nlet tabMonitoring = \"wss-tab-5720\"\nlet tabWhatIf = \"wss-tab-9078\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nlet interactionSystem = Application.autocomplete.InteractionSystem\n\nnotificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\nlet usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\nlet dataLakeNodes = liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")});\nlet dlProps = dataLakeNodes.reduce((acc, dataLakeNode) => {\n  return {\n    ...acc,\n    [dataLakeNode.tag.primitiveID]: Object.entries(dataLakeNode.tag.properties)\n    .filter(p => !p[0].startsWith(\"_\") && p[0] !== \"query\")\n  }\n}, {})\n\nfunction removeLink2DataLakeNodes(nodes){\n    nodes.forEach((node) => {\n        if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n        Object.keys(dlProps).forEach((dln) => {\n            dlProps[dln].forEach(([propertyName, propertyBody]) => {\n                if (propertyName in node.tag.properties) {\n                    expression2static(node, propertyName)\n                }\n            })\n        })\n    })\n};\n\nremoveLink2DataLakeNodes(liveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_well\"\n))\n\n\n// remove datalake nodes\nlet removeNodes = dataLakeNodes;\n\nfor (let rn of removeNodes) {\n    liveDashPanelMonitoring.masterGraph.remove(rn)\n}\n\n// clear link to datalake nodes\nfunction expression2static(node, prop) {\n    if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n        node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n    } else {\n        node.tag.properties[prop].expression = node.tag.properties[prop].value\n    }\n}\nlet username = await usernamePromise\n\nlet tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_tmp_${username}`\n\nawait interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n    console.log(d)\n    let oldTmpFragments = d.data.fragments.filter(fr => {\n        return fr.name === tmpGraphName\n    })\n    for (let otf in oldTmpFragments) {\n        console.log(oldTmpFragments[otf])\n        interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n    }\n})\n\nawait liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n    console.log(fragment)\n    liveDashPanelWhatIf.openFromServer(fragment)\n    let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n    console.log(fr)\n    liveDashPanelMonitoring.openFromServer(fr)\n    workspaceSystem.setActiveTab(tabWhatIf)\n    }\n)\nnotificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "measure_apply_PPD.js",
        "content": "let customActionTitle = \"Apply a measure\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet tableExp = Application.autocomplete.Visualization_EditableTable_3\nlet tableMeasures = Application.autocomplete.Visualization_EditableTable_4\nlet storageSystem = Application.autocomplete.StorageSystem\n\nlet tabMonitoring = \"wss-tab-5465\"\nlet tabWhatIf = \"wss-tab-9479\"\nlet measures_boolean_column = \"to_do\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nlet interactionSystem = Application.autocomplete.InteractionSystem\n\nnotificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\nfunction getLongTableFromGraph(targetLiveDash) {\n    let table = [];\n    for (let node of liveDashPanelWhatIf.masterGraph.nodes) {\n        let primitiveID = node.tag.primitiveID\n        let nodeName = node.tag.properties.Name.value\n\n        for (let prop in node.tag.properties) {\n            if (prop === \"Name\") {\n                continue\n            }\n            let line = {\n                \"primitiveID\": primitiveID,\n                \"nodeName\": nodeName,\n                \"nodeProperty\": prop,\n                \"value\": node.tag.properties[prop].value,\n            }\n            table.push(line)\n        }\n    }\n    return table\n}\n\nfunction fill(node, properties, line) {\n    console.log(node, properties)\n    for (let property of properties) {\n        if (property in node.tag.properties) {\n            node.tag.properties[property].expression = line[property]\n            node.tag.properties[property].value = line[property]\n            node.tag.properties[property].status = \"complete\"\n            console.log(node.tag.properties[property])\n        } else {\n            console.log(`Node ${node.tag.primitiveID} doesn't have a property \"${property}\"`)\n        }\n    }\n}\n\nfunction findNode(propertyWithID, columnWithID, line) {\n    let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n        if (propertyWithID in node.tag.properties) {\n            return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n        } else {\n            return false\n        }\n    })\n    console.log(node)\n    return node\n}\n\nlet measuresDataset = tableMeasures.getDatasetFromTable().filter(lineFromMeasures  => {return lineFromMeasures[measures_boolean_column]})\nconsole.log(measuresDataset)\n\nfor (let i in measuresDataset) {\n    let line = measuresDataset[i]\n    console.log(line)\n    if (\"node_id\" in line && line.node_id !== null && line.node_id !== \"undefined\") {\n        let node = findNode(\"node_id\", \"node_id\", line)\n        if (node === null) {\n            console.log(`Node ${line.node_id} from dataset is not presented in the graph`)\n        } else {\n            // fill(node, wellProperties, line)\n            fill(node, Object.keys(line), line)\n        }\n    } else {\n        let node = findNode(\"node_id_start\", \"node_id_start\", line)\n        if (node === null) {\n            console.log(`Node ${line.node_id_start} (else section) from dataset is not presented in the graph`)\n        } else {\n            // fill(node, pipeProperties, line)\n            fill(node, Object.keys(line), line)\n        }\n    }\n}\n\nlet tableExperiments = tableExp.getDatasetFromTable()\n\nawait Application.autocomplete.EventSystem.actions.find(ac => {return ac.name === \"Solver\"}).callback()\n\nlet tableFromWhatIf = getLongTableFromGraph(liveDashPanelWhatIf)\n\nlet experiments = storageSystem.session.getRecord(\"experimentsPPD\")\nif (experiments && experiments.length !==0) {\n    experiments.push(tableFromWhatIf)\n} else {\n    experiments = [tableFromWhatIf]\n}\nstorageSystem.session.putRecord(\"experimentsPPD\", experiments)\n\nlet updatedTable = []\n\nfor (let lineFromTable in tableExperiments) {\n    console.log(\"---\")\n    console.log(tableExperiments[lineFromTable])\n    let lineFromCurrentExperiment = tableFromWhatIf.find(l => {return l.nodeName === tableExperiments[lineFromTable].nodeName && l.nodeProperty === tableExperiments[lineFromTable].nodeProperty})\n    console.log(lineFromCurrentExperiment)\n    let updatedLine = tableExperiments[lineFromTable]\n    updatedLine[`Experiment ${experiments.length}`] = lineFromCurrentExperiment.value\n    console.log(updatedLine)\n    updatedTable.push(updatedLine)\n}\n\ntableExp.loadSchema(updatedTable[0])\ntableExp.loadData(updatedTable)\nstorageSystem.session.putRecord(\"expTablePPD\", updatedTable)"
    },
    {
        "name": "monitoring_refresh_PPD.js",
        "content": "let customActionTitle = \"Monitoring refresh\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nasync function copyMonitoringGraphForSolver() {\n    let customActionTitle = \"function copyMonitoringGraphForSolver\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let workspaceSystem = Application.autocomplete.WorkspaceSystem\n    let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n\n    let tabMonitoring = \"wss-tab-5720\"\n    let tabWhatIf = \"wss-tab-9078\"\n\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    let interactionSystem = Application.autocomplete.InteractionSystem\n\n    notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\n    let usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\n    let removeNodes = []\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n        removeNodes.push(node)\n    }\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return \"_remove_before_solver\" in node.tag.properties})) {\n        removeNodes.push(node)\n    }\n    for (let rn of removeNodes) {\n        liveDashPanelMonitoring.masterGraph.remove(rn)\n    }\n\n    for (const node_id in liveDashPanelMonitoring.nodes) {\n        let node = liveDashPanelMonitoring.nodes[node_id]\n        if (node_id.includes(\"DataLakeNode\")) {\n            delete node\n        } else {\n            for (const prop in node.tag.properties) {\n                if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n                    node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n                } else {\n                    node.tag.properties[prop].expression = node.tag.properties[prop].value\n                }\n            }\n        }\n    }\n    let username = await usernamePromise\n\n    let tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_monitoring_${username}`\n\n    await interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n        console.log(d)\n        let oldTmpFragments = d.data.fragments.filter(fr => {\n            return fr.name === tmpGraphName\n        })\n        for (let otf in oldTmpFragments) {\n            console.log(oldTmpFragments[otf])\n            interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n        }\n    })\n\n    await liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n          console.log(fragment)\n          let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n          console.log(fr)\n          liveDashPanelMonitoring.openFromServer(fr)\n      }\n    )\n    notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n    return tmpGraphName\n}\nasync function runSolver(tmpGraphName) {\n    let customActionTitle = \"Solver\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let workspaceSystem = Application.autocomplete.WorkspaceSystem\n    let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n    let dataSourceSystem = Application.autocomplete.DataSourceSystem\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    notificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n    let solverOtl = `v2 | dtcd_read_graph \"${tmpGraphName}\" | ks_prepare | ks_calc_df`\n\n    await dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n\n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"start\": {\n                    \"P\": \"startP\",\n                    \"T\": \"startT\",\n                    \"Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"P\": \"endP\",\n                    \"T\": \"endT\",\n                    \"Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"X_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            let props = node.tag.properties;\n\n            if (\"junctionpoint\" === props.object_type.value){\n                return\n            }\n            console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n            if (\n              \"start\" === usage ||\n              \"edge\" === usage ||\n              \"end\" === usage){\n                Object.entries(nodeParamsMapping[usage]).map(\n                  ([param,df]) => {\n                      props[param].expression = line[df];\n                  })\n            }\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                      Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n                } else {\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                // console.log(\"process edgeNode\", edgeNode);\n                processNode(edgeNode, line, \"edge\");\n            }\n        };\n\n        Object.entries(ds).map(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n    })\n    .then(t => {\n        liveDashPanelMonitoring.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch(()=>{\n        console.log(\"Solver flow failed\")\n        notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nasync function startCalculation() {\n    let customActionTitle = \"function startCalculation\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    liveDashPanelMonitoring.startCalculatingGraph()\n    let dataLakeNodes = []\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n        dataLakeNodes.push(node)\n    }\n    var completeCount = 0\n\n    while (completeCount != dataLakeNodes.length) {\n        for (let node of dataLakeNodes) {\n            if (node.tag.properties.query.status === \"complete\") {\n                completeCount += 1\n            }\n        }\n        await new Promise(r => setTimeout(r, 1000))\n    }\n\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nawait startCalculation()\nlet tmpGraphName = await copyMonitoringGraphForSolver()\nawait runSolver(tmpGraphName)"
    },
    {
        "name": "monitoring_refresh.js",
        "content": "let customActionTitle = \"Monitoring refresh\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nasync function copyMonitoringGraphForSolver() {\n    let customActionTitle = \"function copyMonitoringGraphForSolver\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let workspaceSystem = Application.autocomplete.WorkspaceSystem\n    let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\n    let tabMonitoring = \"wss-tab-5720\"\n    let tabWhatIf = \"wss-tab-9078\"\n\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    let interactionSystem = Application.autocomplete.InteractionSystem\n\n    notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\n    let usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\n    let removeNodes = []\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n        removeNodes.push(node)\n    }\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return \"_remove_before_solver\" in node.tag.properties})) {\n        removeNodes.push(node)\n    }\n    for (let rn of removeNodes) {\n        liveDashPanelMonitoring.masterGraph.remove(rn)\n    }\n\n    for (const node_id in liveDashPanelMonitoring.nodes) {\n        let node = liveDashPanelMonitoring.nodes[node_id]\n        if (node_id.includes(\"DataLakeNode\")) {\n            delete node\n        } else {\n            for (const prop in node.tag.properties) {\n                if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n                    node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n                } else {\n                    node.tag.properties[prop].expression = node.tag.properties[prop].value\n                }\n            }\n        }\n    }\n    let username = await usernamePromise\n\n    let tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_monitoring_${username}`\n\n    await interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n        console.log(d)\n        let oldTmpFragments = d.data.fragments.filter(fr => {\n            return fr.name === tmpGraphName\n        })\n        for (let otf in oldTmpFragments) {\n            console.log(oldTmpFragments[otf])\n            interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n        }\n    })\n\n    await liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n          console.log(fragment)\n          let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n          console.log(fr)\n          liveDashPanelMonitoring.openFromServer(fr)\n      }\n    )\n    notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n    return tmpGraphName\n}\nasync function runSolver(tmpGraphName) {\n    let customActionTitle = \"Solver\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let workspaceSystem = Application.autocomplete.WorkspaceSystem\n    let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n    let dataSourceSystem = Application.autocomplete.DataSourceSystem\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    notificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n    let solverOtl = `v2 | dtcd_read_graph \"${tmpGraphName}\" | ks_prepare | ks_calc_df`\n\n    await dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n\n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"start\": {\n                    \"P\": \"startP\",\n                    \"T\": \"startT\",\n                    \"Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"P\": \"endP\",\n                    \"T\": \"endT\",\n                    \"Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"X_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            let props = node.tag.properties;\n\n            if (\"junctionpoint\" === props.object_type.value){\n                return\n            }\n            console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n            if (\n              \"start\" === usage ||\n              \"edge\" === usage ||\n              \"end\" === usage){\n                Object.entries(nodeParamsMapping[usage]).map(\n                  ([param,df]) => {\n                      props[param].expression = line[df];\n                  })\n            }\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                      Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n                } else {\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                // console.log(\"process edgeNode\", edgeNode);\n                processNode(edgeNode, line, \"edge\");\n            }\n        };\n\n        Object.entries(ds).map(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n    })\n    .then(t => {\n        liveDashPanelMonitoring.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch(()=>{\n        console.log(\"Solver flow failed\")\n        notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nasync function startCalculation() {\n    let customActionTitle = \"function startCalculation\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    liveDashPanelMonitoring.startCalculatingGraph()\n    let dataLakeNodes = []\n    for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n        dataLakeNodes.push(node)\n    }\n    var completeCount = 0\n\n    while (completeCount != dataLakeNodes.length) {\n        for (let node of dataLakeNodes) {\n            if (node.tag.properties.query.status === \"complete\") {\n                completeCount += 1\n            }\n        }\n        await new Promise(r => setTimeout(r, 1000))\n    }\n\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nawait startCalculation()\nlet tmpGraphName = await copyMonitoringGraphForSolver()\nawait runSolver(tmpGraphName)"
    },
    {
        "name": "run_solver.js",
        "content": "let customActionTitle = \"Solver\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nnotificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n\nawait liveDashPanelWhatIf.saveToServer({name: liveDashPanelWhatIf.graphMeta.graphName, id: liveDashPanelWhatIf.graphMeta.graphID})\n\nlet solverOtl = `v2 | dtcd_read_graph \"${liveDashPanelWhatIf.graphMeta.graphName}\" | ks_prepare | ks_calc_df`\nawait dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n\n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"start\": {\n                    \"P\": \"startP\",\n                    \"T\": \"startT\",\n                    \"Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"P\": \"endP\",\n                    \"T\": \"endT\",\n                    \"Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"X_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            let props = node.tag.properties;\n\n            if (\"junctionpoint\" === props.object_type.value){\n                return\n            }\n            console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n            if (\n              \"start\" === usage ||\n              \"edge\" === usage ||\n              \"end\" === usage){\n                Object.entries(nodeParamsMapping[usage]).map(\n                  ([param,df]) => {\n                      props[param].expression = line[df];\n                  })\n            }\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                      Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n                } else {\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                // console.log(\"process edgeNode\", edgeNode);\n                processNode(edgeNode, line, \"edge\");\n            }\n        };\n\n        Object.entries(ds).map(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n})\n    .then(t => {\n        liveDashPanelWhatIf.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch(()=>{\n        console.log(\"Solver flow failed\")\n        notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)\n"
    },
    {
        "name": "load_history.js",
        "content": "let customActionTitle = \"Load history\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet storageSystem = Application.autocomplete.StorageSystem\n\nfunction findNode(propertyWithID, columnWithID, line) {\n    console.log(propertyWithID, columnWithID, line)\n    let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n        if (propertyWithID in node.tag.properties) {\n            return node.tag.properties[propertyWithID].value === line[columnWithID]\n        } else {\n            return false\n        }\n    })\n    console.log(node)\n    return node\n}\n\nlet eventColumn = e.column\nif (eventColumn.includes(\"Experiment\")) {\n    let experimentNumber = eventColumn.split(\" \")[1]\n\n    let experiments = storageSystem.session.getRecord(\"experiments\")\n    let experiment = experiments[experimentNumber - 1]\n\n    for (let i in experiment) {\n        let line = experiment[i]\n        console.log(line)\n        let targetNode = findNode(\"Name\", \"nodeName\", line)\n        targetNode[line.nodeProperty] = line.value\n    }\n    console.log(\"Graph was loaded\")\n} else {\n    console.log(\"Not experiment column was clicked\")\n}\n\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "measure_apply.js",
        "content": "let customActionTitle = \"Apply a measure\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet tableExp = Application.autocomplete.Visualization_EditableTable_1\nlet tableMeasures = Application.autocomplete.Visualization_EditableTable_2\nlet storageSystem = Application.autocomplete.StorageSystem\n\nlet tabMonitoring = \"wss-tab-5720\"\nlet tabWhatIf = \"wss-tab-9078\"\nlet measures_boolean_column = \"to_do\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nlet interactionSystem = Application.autocomplete.InteractionSystem\n\nnotificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\nfunction getLongTableFromGraph(targetLiveDash) {\n    let table = [];\n    for (let node of liveDashPanelWhatIf.masterGraph.nodes) {\n        let primitiveID = node.tag.primitiveID\n        let nodeName = node.tag.properties.Name.value\n\n        for (let prop in node.tag.properties) {\n            if (prop === \"Name\") {\n                continue\n            }\n            let line = {\n                \"primitiveID\": primitiveID,\n                \"nodeName\": nodeName,\n                \"nodeProperty\": prop,\n                \"value\": node.tag.properties[prop].value,\n            }\n            table.push(line)\n        }\n    }\n    return table\n}\n\nfunction fill(node, properties, line) {\n    console.log(node, properties)\n    for (let property of properties) {\n        if (property in node.tag.properties) {\n            node.tag.properties[property].expression = line[property]\n            node.tag.properties[property].value = line[property]\n            node.tag.properties[property].status = \"complete\"\n            console.log(node.tag.properties[property])\n        } else {\n            console.log(`Node ${node.tag.primitiveID} doesn't have a property \"${property}\"`)\n        }\n    }\n}\n\nfunction findNode(propertyWithID, columnWithID, line) {\n    let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n        if (propertyWithID in node.tag.properties) {\n            return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n        } else {\n            return false\n        }\n    })\n    console.log(node)\n    return node\n}\n\nlet measuresDataset = tableMeasures.getDatasetFromTable().filter(lineFromMeasures  => {return lineFromMeasures[measures_boolean_column]})\nconsole.log(measuresDataset)\n\nfor (let i in measuresDataset) {\n    let line = measuresDataset[i]\n    console.log(line)\n    if (\"node_id\" in line && line.node_id !== null && line.node_id !== \"undefined\") {\n        let node = findNode(\"node_id\", \"node_id\", line)\n        if (node === null) {\n            console.log(`Node ${line.node_id} from dataset is not presented in the graph`)\n        } else {\n            // fill(node, wellProperties, line)\n            fill(node, Object.keys(line), line)\n        }\n    } else {\n        let node = findNode(\"node_id_start\", \"node_id_start\", line)\n        if (node === null) {\n            console.log(`Node ${line.node_id_start} (else section) from dataset is not presented in the graph`)\n        } else {\n            // fill(node, pipeProperties, line)\n            fill(node, Object.keys(line), line)\n        }\n    }\n}\n\nlet tableExperiments = tableExp.getDatasetFromTable()\n\nawait Application.autocomplete.EventSystem.actions.find(ac => {return ac.name === \"Solver\"}).callback()\n\nlet tableFromWhatIf = getLongTableFromGraph(liveDashPanelWhatIf)\n\nlet experiments = storageSystem.session.getRecord(\"experiments\")\nif (experiments && experiments.length !==0) {\n    experiments.push(tableFromWhatIf)\n} else {\n    experiments = [tableFromWhatIf]\n}\nstorageSystem.session.putRecord(\"experiments\", experiments)\n\nlet updatedTable = []\n\nfor (let lineFromTable in tableExperiments) {\n    console.log(\"---\")\n    console.log(tableExperiments[lineFromTable])\n    let lineFromCurrentExperiment = tableFromWhatIf.find(l => {return l.nodeName === tableExperiments[lineFromTable].nodeName && l.nodeProperty === tableExperiments[lineFromTable].nodeProperty})\n    console.log(lineFromCurrentExperiment)\n    let updatedLine = tableExperiments[lineFromTable]\n    updatedLine[`Experiment ${experiments.length}`] = lineFromCurrentExperiment.value\n    console.log(updatedLine)\n    updatedTable.push(updatedLine)\n}\n\ntableExp.loadSchema(updatedTable[0])\ntableExp.loadData(updatedTable)\nstorageSystem.session.putRecord(\"expTable\", updatedTable)"
    },
    {
        "name": "from_monitoring_to_whatIf_PPD.js",
        "content": "let customActionTitle = \"Switch to WhatIf\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n\nlet tabMonitoring = \"wss-tab-5465\"\nlet tabWhatIf = \"wss-tab-9479\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nlet interactionSystem = Application.autocomplete.InteractionSystem\n\nnotificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\nlet usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\n\nlet dataLakeNodes = liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")});\nlet dlProps = dataLakeNodes.reduce((acc, dataLakeNode) => {\n    return {\n      ...acc,\n      [dataLakeNode.tag.primitiveID]: Object.entries(dataLakeNode.tag.properties)\n      .filter(p => !p[0].startsWith(\"_\") && p[0] !== \"query\")\n    }\n  }, {});\n\n\nlet removeNodes = dataLakeNodes.toArray();\nfor (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return \"_remove_before_solver\" in node.tag.properties})) {\n    removeNodes.push(node)\n}\n\nfor (let rn of removeNodes) {\n    liveDashPanelMonitoring.masterGraph.remove(rn)\n}\n\nfunction removeLink2DataLakeNodes(nodes){\n    nodes.forEach((node) => {\n        if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n        Object.keys(dlProps).forEach((dln) => {\n            dlProps[dln].forEach(([propertyName, propertyBody]) => {\n                if (propertyName in node.tag.properties) {\n                    expression2static(node, propertyName)\n                }\n            })\n        })\n    })\n};\n\nremoveLink2DataLakeNodes(liveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_well_vodazabornaya\"\n))\n\n// clear link to datalake nodes\nfunction expression2static(node, prop) {\n    if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n        node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n    } else {\n        node.tag.properties[prop].expression = node.tag.properties[prop].value\n    }\n}\nlet username = await usernamePromise\n\nlet tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_tmp_${username}`\n\nawait interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n    console.log(d)\n    let oldTmpFragments = d.data.fragments.filter(fr => {\n        return fr.name === tmpGraphName\n    })\n    for (let otf in oldTmpFragments) {\n        console.log(oldTmpFragments[otf])\n        interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n    }\n})\n\nawait liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n      console.log(fragment)\n      liveDashPanelWhatIf.openFromServer(fragment)\n      let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n      console.log(fr)\n      liveDashPanelMonitoring.openFromServer(fr)\n      workspaceSystem.setActiveTab(tabWhatIf)\n  }\n)\nnotificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "measure_tab_on_load.js",
        "content": "if (e.id === \"wss-tab-1947\") {\n    let customActionTitle = \"Measure tab on load\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n    let tableExp = Application.autocomplete.Visualization_EditableTable_1\n    let storageSystem = Application.autocomplete.StorageSystem\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    function getLongTableFromGraph(targetLiveDash) {\n        let table = [];\n        for (let node of liveDashPanelWhatIf.masterGraph.nodes) {\n            let primitiveID = node.tag.primitiveID\n            let nodeName = node.tag.properties.Name.value\n\n            for (let prop in node.tag.properties) {\n                if (prop === \"Name\") {\n                    continue\n                }\n                let line = {\n                    \"primitiveID\": primitiveID,\n                    \"nodeName\": nodeName,\n                    \"nodeProperty\": prop,\n                    \"monitoring\": node.tag.properties[prop].value,\n                }\n                table.push(line)\n            }\n        }\n        return table\n    }\n\n    let expTable = storageSystem.session.getRecord(\"expTable\")\n    let finalTable\n    console.log(expTable)\n    if (expTable && expTable.length !== 0) {\n        finalTable = expTable\n    } else {\n        finalTable = getLongTableFromGraph(liveDashPanelWhatIf)\n        storageSystem.session.putRecord(\"expTable\", finalTable)\n    }\n    console.log(finalTable)\n    if (finalTable.length === 0) {\n        notificationSystem.create(customActionTitle, \"Проверьте граф на What-If вкладке\", notificationSettingsFail)\n    } else {\n        notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n        await new Promise(r => setTimeout(r, 2000))\n        tableExp.loadSchema(finalTable[0])\n        tableExp.loadData(finalTable)\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    }\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}\nif (e.id === \"wss-tab-5058\") {\n    let customActionTitle = \"Measure tab on load\"\n    console.log(`Custom action \"${customActionTitle}\" started`)\n    let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n    let tableExp = Application.autocomplete.Visualization_EditableTable_3\n    let storageSystem = Application.autocomplete.StorageSystem\n    let notificationSystem = Application.autocomplete.NotificationSystem\n    let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n    let notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\n    let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n    function getLongTableFromGraph(targetLiveDash) {\n        let table = [];\n        for (let node of liveDashPanelWhatIf.masterGraph.nodes) {\n            let primitiveID = node.tag.primitiveID\n            let nodeName = node.tag.properties.Name.value\n\n            for (let prop in node.tag.properties) {\n                if (prop === \"Name\") {\n                    continue\n                }\n                let line = {\n                    \"primitiveID\": primitiveID,\n                    \"nodeName\": nodeName,\n                    \"nodeProperty\": prop,\n                    \"monitoring\": node.tag.properties[prop].value,\n                }\n                table.push(line)\n            }\n        }\n        return table\n    }\n\n    let expTable = storageSystem.session.getRecord(\"expTablePPD\")\n    let finalTable\n    console.log(expTable)\n    if (expTable && expTable.length !== 0) {\n        finalTable = expTable\n    } else {\n        finalTable = getLongTableFromGraph(liveDashPanelWhatIf)\n        storageSystem.session.putRecord(\"expTablePPD\", finalTable)\n    }\n    console.log(finalTable)\n    if (finalTable.length === 0) {\n        notificationSystem.create(customActionTitle, \"Проверьте граф на What-If вкладке\", notificationSettingsFail)\n    } else {\n        notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n        await new Promise(r => setTimeout(r, 2000))\n        tableExp.loadSchema(finalTable[0])\n        tableExp.loadData(finalTable)\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    }\n    console.log(`Custom action \"${customActionTitle}\" finished`)\n}"
    },
    {
        "name": "run_solver_PPD.js",
        "content": "let customActionTitle = \"Solver\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nnotificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n\nawait liveDashPanelWhatIf.saveToServer({name: liveDashPanelWhatIf.graphMeta.graphName, id: liveDashPanelWhatIf.graphMeta.graphID})\n\nlet solverOtl = `v2 | dtcd_read_graph \"${liveDashPanelWhatIf.graphMeta.graphName}\" | ks_prepare | ks_calc_df`\nawait dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n.then(ds => {\n\n    function processNode(node, line, usage) {\n        const nodeParamsMapping = {\n            \"start\": {\n                \"P\": \"startP\",\n                \"T\": \"startT\",\n                \"Q_m3_day\": \"start_Q_m3_day\"\n            },\n            \"end\": {\n                \"P\": \"endP\",\n                \"T\": \"endT\",\n                \"Q_m3_day\": \"end_Q_m3_day\"\n            },\n            \"edge\": {\n                \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                \"X_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                \"velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n            }\n        };\n        let props = node.tag.properties;\n\n        if (\"junctionpoint\" === props.object_type.value){\n            return\n        }\n        console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n        if (\n          \"start\" === usage ||\n          \"edge\" === usage ||\n          \"end\" === usage){\n            Object.entries(nodeParamsMapping[usage]).map(\n              ([param,df]) => {\n                  props[param].expression = line[df];\n              })\n        }\n    }\n\n    function findNode(propertyWithID, columnWithID, line) {\n        let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n            if (propertyWithID in node.tag.properties) {\n                return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n            } else {\n                return false\n            }\n        })\n        console.log(node)\n        return node\n    }\n\n    function processDfLine(line) {\n        let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n        if (null != sourceNode){\n            processNode(sourceNode, line, \"start\");\n        }\n        let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n        if (null != targetNode){\n            processNode(targetNode, line, \"end\");\n        }\n\n        let edgeNode = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n            if (\n              'node_id_start' in node.tag.properties &&\n              'node_id_end' in node.tag.properties) {\n                return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                  Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n            } else {\n                return false;\n            }\n        });\n        if (null != edgeNode){\n            // console.log(\"process edgeNode\", edgeNode);\n            processNode(edgeNode, line, \"edge\");\n        }\n    };\n\n    Object.entries(ds).map(([id, line]) => {\n        processDfLine(line);\n    })\n\n    return true\n})\n.then(t => {\n    liveDashPanelWhatIf.startCalculatingGraph()\n    notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n})\n.catch(()=>{\n    console.log(\"Solver flow failed\")\n    notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "load_history_PPD.js",
        "content": "let customActionTitle = \"Load history\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet storageSystem = Application.autocomplete.StorageSystem\n\nfunction findNode(propertyWithID, columnWithID, line) {\n    console.log(propertyWithID, columnWithID, line)\n    let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n        if (propertyWithID in node.tag.properties) {\n            return node.tag.properties[propertyWithID].value === line[columnWithID]\n        } else {\n            return false\n        }\n    })\n    console.log(node)\n    return node\n}\n\nlet eventColumn = e.column\nif (eventColumn.includes(\"Experiment\")) {\n    let experimentNumber = eventColumn.split(\" \")[1]\n\n    let experiments = storageSystem.session.getRecord(\"experimentsPPD\")\n    let experiment = experiments[experimentNumber - 1]\n\n    for (let i in experiment) {\n        let line = experiment[i]\n        console.log(line)\n        let targetNode = findNode(\"Name\", \"nodeName\", line)\n        targetNode[line.nodeProperty] = line.value\n    }\n    console.log(\"Graph was loaded\")\n} else {\n    console.log(\"Not experiment column was clicked\")\n}\n\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "removeProps",
        "content": "let customActionTitle = \"remove props\"\n\nconsole.log(`Custom Snippet \"${customActionTitle}\" started`)\n\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\n//let tabMonitoring = \"wss-tab-5720\"\n//let tabWhatIf = \"wss-tab-9078\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n\n\nfunction removeLink2DataLakeNodes(nodes){\n    nodes.forEach((node) => {\n        if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n        Object.keys(dlProps).forEach((dln) => {\n            dlProps[dln].forEach(([propertyName, propertyBody]) => {\n                if (propertyName in node.tag.properties) {\n                    expression2static(node, propertyName)\n                }\n            })\n        })\n    })\n};\n\nlet propertyName = \"gas_factor_m3_m3\";\n\nliveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_well\"\n).forEach(node => {\n    if (propertyName in node.tag.properties) {\n        delete node.tag.properties[propertyName]\n    }\n})\n\n\nconsole.log(`remove \"${propertyName}\" done`);"
    },
    {
        "name": "clearResPropsMonitoring",
        "content": "let customActionTitle = \"clearResPropsWhatIf\"\n\nconsole.log(`Custom Snippet \"${customActionTitle}\" started`)\n\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\n\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\n// let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\n// let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n\nliveDashPanelMonitoring.masterGraph.nodes.toArray().forEach(\n    node => {\n    Object.entries(node.tag.properties).forEach(\n        ([name, property]) => {\n        if (name.includes(\"res_\")) {\n            property.expression = \"\";\n            //property.status = \"new\";\n        }\n    })\n});"
    },
    {
        "name": "checkWhatifConditions",
        "content": "let customActionTitle = \"clearResPropsMonitoring\"\n\nconsole.log(`Custom Snippet \"${customActionTitle}\" started`)\n\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\nliveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => {\n        if (node.tag.properties?.object_type) {\n            return (node.tag.primitiveName === \"oil_well\")\n        }\n    }\n).filter(\n    node => {\n        return ((node.tag.properties.LiquidDensity.value == \"\") \n                || (node.tag.properties.LiquidDebit.value == null)\n                || (node.tag.properties.LiquidDensity.value == null)\n                    );\n        // node.tag.properties.Value.value === null\n    }).forEach(\n    node => {\n        console.log(`error in node ${node.tag.primitiveID} conditions`);\n        // node.tag.properties.Value.expression === \"0.0001\";\n        // node.tag.properties.Value.value === 0.0001;\n        // node.tag.properties.Value.status === \"new\";\n    }\n)\n\n\nliveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => {\n        if (node.tag.properties?.object_type) {\n            return (node.tag.primitiveName === \"oil_dns\")\n        }\n    }\n).filter(\n    node => node.tag.properties.Kind.value != \"\").filter(\n    node => node.tag.properties.Value.value === null).forEach(\n    node => {\n        console.log(`error in node ${node.tag.primitiveID} conditions`);\n        // node.tag.properties.Value.expression === \"100\";\n        // node.tag.properties.Value.status === \"new\";\n    }\n)"
    },
    {
        "name": "__runWhatif",
        "content": "let customActionTitle = \"Solver\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nnotificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n\nawait liveDashPanelWhatIf.saveToServer({name: liveDashPanelWhatIf.graphMeta.graphName, id: liveDashPanelWhatIf.graphMeta.graphID})\n\nlet solverOtl = `v2 | dtcd_read_graph \"${liveDashPanelWhatIf.graphMeta.graphName}\" | ks_prepare | ks_calc_df`\nawait dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n\n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"start\": {\n                    \"P\": \"startP\",\n                    \"T\": \"startT\",\n                    \"Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"P\": \"endP\",\n                    \"T\": \"endT\",\n                    \"Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    // \"X_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"res_velocity_m_sec\": \"res_velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            let props = node.tag.properties;\n\n            if (\"junctionpoint\" === props.object_type.value){\n                return\n            }\n            //console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n            if (\n              \"start\" === usage ||\n              \"edge\" === usage ||\n              \"end\" === usage){\n                Object.entries(nodeParamsMapping[usage]).map(\n                  ([param,df]) => {\n                      //console.log(\"eval param::\", param);\n                      props[param].expression = line[df];\n                  })\n            }\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            //console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            //console.log(\"eval line\", line);\n            \n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                      Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n                } else {\n                    //console.log(\"no data for\", line.node_id_start, line.node_id_end);\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                // console.log(\"process edgeNode\", edgeNode);\n                processNode(edgeNode, line, \"edge\");\n            } else {\n                console.log(\"line::\", line);\n            }\n        };\n\n        Object.entries(ds).map(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n})\n    .then(t => {\n        liveDashPanelWhatIf.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch(()=>{\n        console.log(\"Solver flow failed\")\n        notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "__propsUpdatePPD",
        "content": "let liveDash = Application.autocomplete.LiveDashPanel_4;\n\nlet dataLakeNodes = liveDash.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})\n\nlet dlProps = dataLakeNodes.reduce((acc, dataLakeNode) => {\n  return {\n    ...acc,\n    [dataLakeNode.tag.primitiveID]: Object.entries(dataLakeNode.tag.properties)\n    .filter(p => !p[0].startsWith(\"_\") && p[0] !== \"query\")\n  }\n}, {})\n\nliveDash.masterGraph.nodes.forEach((node) => {\n  if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n  Object.keys(dlProps).forEach((dln) => {\n    dlProps[dln].forEach(([propertyName,propertyBody]) => {\n      if ( propertyName in node.tag.properties) {\n        node.tag.properties[propertyName]\n          .expression = `\n          +(${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.wellNum})[0][${dln}.${propertyName}]) !== NaN ?\n          +(${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.wellNum})[0][${dln}.${propertyName}]) :\n          ${dln}.query.filter(wn => {return wn[\"__well_num\"] == this.wellNum})[0][${dln}.${propertyName}]\n          `\n      }\n    })\n  })\n})\n\n// update inner links\n\nliveDash.masterGraph.nodes.toArray().filter(\n    node => {\n        if (node.tag.properties?.object_type) {\n            return (node.tag.primitiveName === \"oil_well_vodazabornaya\")\n        }\n    }\n).forEach(node => node.tag.properties.Value.expression = \"this.zakachka\")\n\nliveDash.masterGraph.nodes.toArray().filter(\n    node => {\n        if (node.tag.properties?.object_type) {\n            return (node.tag.primitiveName === \"oil_kns\")\n        }\n    }\n).forEach(node => node.tag.properties.Value.expression = \"this.Pumps_Outlet_Pressure_atm\")\n\nconsole.log(\"PPD added link to datalake nodes\");"
    },
    {
        "name": "__modPPD",
        "content": "\nfunction addPropsbyObjectType(liveDash, nodeParamsMapping, graphObjectTypes) {\n  const defExpr = {\n    \"type\": \"expression\",\n    \"expression\": \"\",\n    \"status\": \"completed\",\n    \"value\": \"\"\n  }\n\n  Object.entries(graphObjectTypes).forEach(([target_object_type, node_class]) => {\n    let targetNodes = liveDash.masterGraph.nodes.toArray().filter(\n      node => node.tag.primitiveName === target_object_type\n    );\n    let addProps = nodeParamsMapping[node_class];\n\n    targetNodes.forEach(node => {\n      Object.entries(addProps).map(([p, info]) => {\n        node.tag.properties[p] = defExpr;\n      })\n    })\n\n  })\n};\n\nfunction delPropsbyObjectType(liveDash, delPropsMapping) {\n  Object.entries(delPropsMapping).forEach(([target_object_type, delProps]) => {\n    let targetNodes = liveDash.masterGraph.nodes.toArray().filter(\n      node => node.tag.primitiveName === target_object_type\n    );\n    targetNodes.forEach(node => {\n      delProps.forEach(p => {\n        delete node.tag.properties[p];\n      })\n    })\n  })\n};\n\nconst nodeParamsMapping = {\n  \"inlet\": { // start\n    \"res_P\": \"startP\",\n    \"res_T\": \"startT\",\n    \"res_Q_m3_day\": \"start_Q_m3_day\"\n  },\n  \"junction\": { // junction && pad| vrb \n    \"res_P\": \"startP\",\n    \"res_T\": \"startT\"\n    //no Q_m3_day data for this node\n  },\n  \"outlet\": { // end\n    \"res_P\": \"endP\",\n    \"res_T\": \"endT\",\n    \"res_Q_m3_day\": \"end_Q_m3_day\"\n  },\n  \"edge\": { // pipe\n    // \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n    // \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n    // \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n    \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n    \"res_velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n  }\n};\n\nconst graphObjectTypes = {\n  \"oil_kns\": \"inlet\",\n  \"oil_pipe_ppd\": \"edge\",\n  \"oil_junction_ppd\": \"junction\",\n  \"oil_vrb\": \"junction\",\n  \"oil_well_vodazabornaya\": \"outlet\"\n};\n\nlet liveDash = Application.autocomplete.LiveDashPanel_4;\n\n// addPropsbyObjectType(liveDash, nodeParamsMapping, graphObjectTypes);\n// console.log(\"PPD added res properties 3\");\n\n\nconst delPropsMapping = {\n  \"oil_kns\": [],\n  \"oil_pipe_ppd\": [\n    \"res_watercut_percent\",// Обводненность,TRUE\n    \"res_liquid_density_kg_m3\",// Плотность жидкости,\n    \"res_pump_power_watt\",// Мощность насоса,TRUE\n  ],\n  \"oil_junction_ppd\": [],\n  \"oil_vrb\": [],\n  \"oil_well_vodazabornaya\": []\n};\n\ndelPropsbyObjectType(liveDash, delPropsMapping)\nconsole.log(\"PPD del some res properties\");\n\n"
    },
    {
        "name": "__PPDlink2Datalakeupd",
        "content": "let liveDash = Application.autocomplete.LiveDashPanel_4;\n\nlet dataLakeNode = liveDash.masterGraph.nodes.toArray().find(\n    node => {\n        return node.tag.primitiveName === \"DataLakeNode\";\n        //  && node.tag.properties?.['_usage'].expression === '\"index_monitoring\"'\n    } \n);\n\nconsole.log(\"dataLakeNode::\", dataLakeNode);\n\n// props modification\nfunction fillIndexQueries({\n    nodes,\n    baseQuery, propsMapping\n}) {\n    nodes.toArray().forEach((node) => {\n        Object.entries(propsMapping).forEach(([propertyName, propertyBody]) => {\n            if (propertyName in node.tag.properties) {\n                const query = `\nlet q = ${baseQuery}[\"${propertyBody}\"];\n+(q) !== NaN ? +(q) : q`;\n                node.tag.properties[propertyName].expression = query;\n            }\n        })\n    })\n}\n\nfunction buildIndexQuery({\n    DataLakeNodeID, DataLakeNodeQParam,\n    dfSearchCol, dfSearchKey\n}) {\n    return `${DataLakeNodeID}.${DataLakeNodeQParam}.filter(line => {return line[\\\"${dfSearchCol}\\\"] == this.${dfSearchKey}})[0]`;\n}\n\n// DNS\n// fillIndexQueries({\n//     nodes: liveDash.masterGraph.nodes.filter(\n//         node => node.tag.primitiveName === \"oil_well\"\n//     ),\n//     baseQuery: buildIndexQuery({\n//         DataLakeNodeID: dataLakeNode.tag.primitiveID, // node we refer to\n//         DataLakeNodeQParam: \"query\", // prop name in datalake node we refer to\n//         dfSearchCol: \"__well_num\", //index col name\n//         dfSearchKey: \"node_id\" // search by node prop\n//     }),\n//     propsMapping: {\n//         \"VolumeWater\": 'neftWellopVolumeWater',\n//         \"frequency\": 'neftWellopPumpCurrentFreqTm',\n//         \"Value\": \"value\"\n//     }\n// })\n\n// KNS\n\n// const queryKNS = `| otstats index=tailaki_sensor_data metric_name=\"adkuWell_nag_WaterConsumption\"\n// | stats latest(value) as value by __well_num, metric_name | pivot __well_num metric_name value\n// | eval value=adkuWell_nag_WaterConsumption / 86.4\n// | fillnull value=0 value`;\n\nfillIndexQueries({\n    nodes: liveDash.masterGraph.nodes.filter(\n        node => node.tag.primitiveName === \"oil_well_vodazabornaya\"\n    ),\n    baseQuery: buildIndexQuery({\n        DataLakeNodeID: dataLakeNode.tag.primitiveID, // node we refer to\n        DataLakeNodeQParam: \"query\", // prop name in datalake node we refer to\n        dfSearchCol: \"__well_num\", //index col name\n        dfSearchKey: \"well_num\" // search by node prop\n    }),\n    propsMapping: {\n        // \"VolumeWater\": 'neftWellopVolumeWater',\n        // \"frequency\": 'neftWellopPumpCurrentFreqTm',\n        // \"Value\": \"value\"\n        \"zakachka\": \"adkuWell_nag_WaterConsumption\"\n    }\n})\n\n\n\nconsole.log(\"PPD added link to datalake nodes 2\");"
    },
    {
        "name": "__runPPDWhatif",
        "content": "let customActionTitle = \"Solver PPD Whatif\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nnotificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n\nawait liveDashPanelWhatIf.saveToServer({name: liveDashPanelWhatIf.graphMeta.graphName, id: liveDashPanelWhatIf.graphMeta.graphID})\nlet notificationSettingsWarning = {type: \"warning\", floatTime: 5, floatMode: true}\nif (!liveDashPanelWhatIf.masterGraph.nodes.toArray().find(node=>{return node.tag.primitiveID.includes(\"oil_kns\")}).tag.properties._check.value) {\n    notificationSystem.create(customActionTitle, \"Cумма всех закачек скважин не равна входящей\", notificationSettingsWarning)}\n\nlet solverOtl = `v2 | dtcd_read_graph \"${liveDashPanelWhatIf.graphMeta.graphName}\" | ks_prepare | ks_calc_df network_kind=water`\nawait dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n      \n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"inlet\": { // start\n                    \"res_P\": \"startP\",\n                    \"res_T\": \"startT\",\n                    \"res_Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"junction\": { //start junction && pad| vrb \n                    \"res_P\": \"startP\",\n                    \"res_T\": \"startT\"\n                    //no Q_m3_day data for this node\n                },\n                \"junction_end\": { //start junction && pad| vrb \n                    \"res_P\": \"endP\",\n                    \"res_T\": \"endT\"\n                    //no Q_m3_day data for this node\n                },\n                \"outlet\": { // end\n                    \"res_P\": \"endP\",\n                    \"res_T\": \"endT\",\n                    \"res_Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": { // pipe\n                    // \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    // \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    // \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"res_velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            const graphObjectTypes = {\n                \"oil_kns\": \"inlet\",\n                \"oil_pipe_ppd\": \"edge\",\n                \"oil_junction_ppd\": \"junction\",\n                \"oil_vrb\": \"junction\",\n                \"oil_well_vodazabornaya\": \"outlet\"\n            };\n            let node_type = graphObjectTypes[node.tag.primitiveName];\n            if ((node_type === \"junction\") && (\"end\" === usage)){\n                node_type = \"junction_end\";\n            }\n            let props = node.tag.properties;\n            // console.log(\"eval \", node_type, node.tag.primitiveID, props, line);\n            Object.entries(nodeParamsMapping[node_type]).forEach(\n                ([param,df]) => {\n                    props[param].expression = line[df];\n                    props[param].value = line[df];\n                    props[param].status = \"complete\";\n                }\n            )\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return String(node.tag.properties[propertyWithID].value) === String(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            //console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return String(line.node_id_start) === String(node.tag.properties.node_id_start.value) &&\n                      String(line.node_id_end) === String(node.tag.properties.node_id_end.value)\n                } else {\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                //console.log(\"edge\", node.tag.primitiveID, node.tag.properties, line);\n                processNode(edgeNode, line, \"edge\");\n            }\n            \n        };\n\n        Object.entries(ds).forEach(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n})\n     .then(t => {\n        liveDashPanelWhatIf.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch((e)=>{\n        console.log(\"Solver flow failed\")\n        console.log(e);\n        notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "__refreshPPD",
        "content": "let customActionTitle = \"Monitoring refresh PPD\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = { type: \"success\", floatTime: 5, floatMode: true }\nlet notificationSettingsFail = { type: \"error\", floatTime: 5, floatMode: true }\nlet notificationSettingsInfo = { type: \"info\", floatTime: 5, floatMode: true }\n\nasync function copyMonitoringGraphForSolver() {\n  let customActionTitle = \"function copyMonitoringGraphForSolver\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  let workspaceSystem = Application.autocomplete.WorkspaceSystem\n  let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\n  let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n\n  let tabMonitoring = \"wss-tab-5720\"\n  let tabWhatIf = \"wss-tab-9078\"\n\n  let notificationSystem = Application.autocomplete.NotificationSystem\n  let notificationSettingsSuccess = { type: \"success\", floatTime: 5, floatMode: true }\n  let notificationSettingsFail = { type: \"fail\", floatTime: 5, floatMode: true }\n  let notificationSettingsInfo = { type: \"info\", floatTime: 5, floatMode: true }\n\n  let interactionSystem = Application.autocomplete.InteractionSystem\n\n  notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\n  let usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => { return d.data.username })\n\n  let removeNodes = []\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => { return node.tag.primitiveID.includes(\"DataLakeNode\") })) {\n    removeNodes.push(node)\n  }\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => { return \"_remove_before_solver\" in node.tag.properties })) {\n    removeNodes.push(node)\n  }\n  for (let rn of removeNodes) {\n    liveDashPanelMonitoring.masterGraph.remove(rn)\n  }\n\n  for (const node_id in liveDashPanelMonitoring.nodes) {\n    let node = liveDashPanelMonitoring.nodes[node_id]\n    if (node_id.includes(\"DataLakeNode\")) {\n      delete node\n    } else {\n      for (const prop in node.tag.properties) {\n        if (typeof (node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n          node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n        } else {\n          node.tag.properties[prop].expression = node.tag.properties[prop].value\n        }\n      }\n    }\n  }\n  let username = await usernamePromise\n\n  let tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_monitoring_${username}`\n\n  await interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n    console.log(d)\n    let oldTmpFragments = d.data.fragments.filter(fr => {\n      return fr.name === tmpGraphName\n    })\n    for (let otf in oldTmpFragments) {\n      console.log(oldTmpFragments[otf])\n      interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n    }\n  })\n\n  await liveDashPanelMonitoring.saveAs({ \"name\": tmpGraphName }).then(fragment => {\n    console.log(fragment)\n    let fr = { \"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName }\n    console.log(fr)\n    liveDashPanelMonitoring.openFromServer(fr)\n  }\n  )\n  notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n  return tmpGraphName\n}\nasync function runSolver(tmpGraphName) {\n  let customActionTitle = \"Solver\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  let workspaceSystem = Application.autocomplete.WorkspaceSystem\n  let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_4\n  let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_5\n  let dataSourceSystem = Application.autocomplete.DataSourceSystem\n  let notificationSystem = Application.autocomplete.NotificationSystem\n  let notificationSettingsSuccess = { type: \"success\", floatTime: 5, floatMode: true }\n  let notificationSettingsFail = { type: \"fail\", floatTime: 5, floatMode: true }\n  let notificationSettingsInfo = { type: \"info\", floatTime: 5, floatMode: true }\n\n  notificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n  let notificationSettingsWarning = { type: \"warning\", floatTime: 5, floatMode: true }\n  \n  let oilKSNnode = liveDashPanelMonitoring.masterGraph.nodes.toArray().find(node => {\n    return node.tag.primitiveName === \"oil_kns\"\n  });\n  if (oilKSNnode != null) {\n    if (!oilKSNnode.tag.properties._check.value) {\n      notificationSystem.create(customActionTitle, \"Cумма всех закачек скважин не равна входящей\", notificationSettingsWarning)\n    }\n  }\n  \n  let solverOtl = `v2 | dtcd_read_graph \"${tmpGraphName}\" | ks_prepare | ks_calc_df network_kind=water`\n  console.log(\"solverOtl PPD resresh\\n\", solverOtl);\n  await dataSourceSystem.oneShotRun(\"otl\", { cache_ttl: 5, queryString: solverOtl })\n    .then(ds => {\n\n      function processNode(node, line, usage) {\n        const nodeParamsMapping = {\n          \"inlet\": { // start\n            \"res_P\": \"startP\",\n            \"res_T\": \"startT\",\n            \"res_Q_m3_day\": \"start_Q_m3_day\"\n          },\n          \"junction\": { //start junction && pad| vrb \n            \"res_P\": \"startP\",\n            \"res_T\": \"startT\"\n            //no Q_m3_day data for this node\n          },\n          \"junction_end\": { //start junction && pad| vrb \n            \"res_P\": \"endP\",\n            \"res_T\": \"endT\"\n            //no Q_m3_day data for this node\n          },\n          \"outlet\": { // end\n            \"res_P\": \"endP\",\n            \"res_T\": \"endT\",\n            \"res_Q_m3_day\": \"end_Q_m3_day\"\n          },\n          \"edge\": { // pipe\n            // \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n            // \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n            // \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n            \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n            \"res_velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n          }\n        };\n        const graphObjectTypes = {\n            \"oil_kns\": \"inlet\",\n            \"oil_pipe_ppd\": \"edge\",\n            \"oil_junction_ppd\": \"junction\",\n            \"oil_vrb\": \"junction\",\n            \"oil_well_vodazabornaya\": \"outlet\"\n        };\n        let node_type = graphObjectTypes[node.tag.primitiveName];\n        if ((node_type === \"junction\") && (\"end\" === usage)) {\n          node_type = \"junction_end\";\n        }\n        let props = node.tag.properties;\n        console.log(\"eval \", node_type, node.tag.primitiveID, props, line);\n        Object.entries(nodeParamsMapping[node_type]).forEach(\n          ([param, df]) => {\n            props[param].expression = line[df];\n            props[param].value = line[df];\n            props[param].status = \"complete\";\n          }\n        )\n      }\n\n      function findNode(propertyWithID, columnWithID, line) {\n        let node = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n          if (propertyWithID in node.tag.properties) {\n            return String(node.tag.properties[propertyWithID].value) === String(line[columnWithID])\n          } else {\n            return false\n          }\n        })\n        return node\n      }\n\n      function processDfLine(line) {\n        let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n        if (null != sourceNode) {\n          processNode(sourceNode, line, \"start\");\n        }\n        let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n        if (null != targetNode) {\n          processNode(targetNode, line, \"end\");\n        }\n\n        let edgeNode = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n          if (\n            'node_id_start' in node.tag.properties &&\n            'node_id_end' in node.tag.properties) {\n            return String(line.node_id_start) === String(node.tag.properties.node_id_start.value) &&\n              String(line.node_id_end) === String(node.tag.properties.node_id_end.value)\n          } else {\n            return false;\n          }\n        });\n        if (null != edgeNode) {\n          processNode(edgeNode, line, \"edge\");\n        }\n      };\n\n      Object.entries(ds).forEach(([id, line]) => {\n        processDfLine(line);\n      })\n\n      return true\n    })\n    .then(t => {\n      liveDashPanelMonitoring.startCalculatingGraph()\n      notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n    })\n    .catch((e) => {\n      console.log(\"Solver flow failed\", e)\n      notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)\n    })\n\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nasync function startCalculation() {\n  let customActionTitle = \"function startCalculation\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  liveDashPanelMonitoring.startCalculatingGraph()\n  let dataLakeNodes = []\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => { return node.tag.primitiveID.includes(\"DataLakeNode\") })) {\n    dataLakeNodes.push(node)\n  }\n  var completeCount = 0\n\n  while (completeCount != dataLakeNodes.length) {\n    for (let node of dataLakeNodes) {\n      if (node.tag.properties.query.status === \"complete\") {\n        completeCount += 1\n      }\n    }\n    await new Promise(r => setTimeout(r, 1000))\n  }\n\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nawait startCalculation()\nlet tmpGraphName = await copyMonitoringGraphForSolver()\nawait runSolver(tmpGraphName)"
    },
    {
        "name": "__fixPPDpipeIds",
        "content": "let liveDashPanelPPDMonitoring = Application.autocomplete.LiveDashPanel_4;\n\n// liveDashPanelPPDMonitoring.masterGraph.nodes.toArray().filter(\n//     node => node.tag.primitiveName === \"oil_well_vodazabornaya\"\n// ).forEach(\n//     node => {\n//         let wellNum = Array.from(node.tag.properties.node_id.expression.matchAll(/\\d+/g)).at(-1)[0]\n//         node.tag.properties.node_id.expression = wellNum\n//         node.tag.properties.node_id.value = wellNum\n//         node.tag.properties.node_id.status = \"complete\"\n//     }\n// )\n\n// liveDashPanelPPDMonitoring.masterGraph.nodes.toArray().filter(\n//     node => node.tag.primitiveName === \"oil_vrb\"\n// ).forEach(\n//     node => {\n//         let wellNum = Array.from(node.tag.properties.node_id.expression.matchAll(/\\d+/g)).at(-1)[0]\n//         node.tag.properties.node_id.expression = `\"pad_${wellNum}\"`\n//         node.tag.properties.node_id.value = `pad_${wellNum}`\n//         node.tag.properties.node_id.status = \"complete\"\n//     }\n// )\n\nliveDashPanelPPDMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_pipe_ppd\"\n).forEach(\n    node => {\n        console.log(node)\n        let neighbors = liveDashPanelPPDMonitoring.masterGraph.neighbors(node).toArray()\n        console.log(neighbors)\n        for (let neighbor of neighbors) {\n            if (neighbor.tag.primitiveName === \"oil_vrb\") {\n                node.tag.properties.node_id_start.expression = neighbor.tag.properties.node_id.expression\n                node.tag.properties.node_id_start.value = neighbor.tag.properties.node_id.value\n                node.tag.properties.node_id_start.status = \"complete\"\n            } else if (neighbor.tag.primitiveName === \"oil_well_vodazabornaya\") {\n                node.tag.properties.node_id_end.expression = neighbor.tag.properties.node_id.expression\n                node.tag.properties.node_id_end.value = neighbor.tag.properties.node_id.value\n                node.tag.properties.node_id_end.status = \"complete\"\n            } else{\n                console.log(\"unexpected neighbor\", neighbor)\n            }\n        }\n    }\n)"
    },
    {
        "name": "ns2w",
        "content": "let customActionTitle = \"Switch to WhatIf\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\nlet tabMonitoring = \"wss-tab-5720\"\nlet tabWhatIf = \"wss-tab-9078\"\n\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nlet interactionSystem = Application.autocomplete.InteractionSystem\n\nnotificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\nlet usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\nlet dataLakeNodes = liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")});\nlet dlProps = dataLakeNodes.reduce((acc, dataLakeNode) => {\n  return {\n    ...acc,\n    [dataLakeNode.tag.primitiveID]: Object.entries(dataLakeNode.tag.properties)\n    .filter(p => !p[0].startsWith(\"_\") && p[0] !== \"query\")\n  }\n}, {});\n\nfunction removeLink2DataLakeNodes(nodes){\n    nodes.forEach((node) => {\n        if (node.tag.primitiveID.includes(\"DataLakeNode\")) return\n        Object.keys(dlProps).forEach((dln) => {\n            dlProps[dln].forEach(([propertyName, propertyBody]) => {\n                if (propertyName in node.tag.properties) {\n                    expression2static(node, propertyName)\n                }\n            })\n        })\n    })\n};\n\nremoveLink2DataLakeNodes(liveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_well\"\n))\n\nremoveLink2DataLakeNodes(liveDashPanelMonitoring.masterGraph.nodes.toArray().filter(\n    node => node.tag.primitiveName === \"oil_dns\"\n))\n\n// remove datalake nodes\nlet removeNodes = dataLakeNodes;\n\nfor (let rn of removeNodes) {\n    liveDashPanelMonitoring.masterGraph.remove(rn)\n}\n\n// clear link to datalake nodes\nfunction expression2static(node, prop) {\n    if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n        node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n    } else {\n        node.tag.properties[prop].expression = node.tag.properties[prop].value\n    }\n}\nlet username = await usernamePromise\n\nlet tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_tmp_${username}`\n\nawait interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n    console.log(d)\n    let oldTmpFragments = d.data.fragments.filter(fr => {\n        return fr.name === tmpGraphName\n    })\n    for (let otf in oldTmpFragments) {\n        console.log(oldTmpFragments[otf])\n        interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n    }\n})\n\nawait liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n    console.log(fragment)\n    liveDashPanelWhatIf.openFromServer(fragment)\n    let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n    console.log(fr)\n    liveDashPanelMonitoring.openFromServer(fr)\n    workspaceSystem.setActiveTab(tabWhatIf)\n    }\n)\nnotificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "_v2Solver",
        "content": "let customActionTitle = \"Solver\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nnotificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n\nawait liveDashPanelWhatIf.saveToServer({name: liveDashPanelWhatIf.graphMeta.graphName, id: liveDashPanelWhatIf.graphMeta.graphID})\n\nlet solverOtl = `v2 | dtcd_read_graph \"${liveDashPanelWhatIf.graphMeta.graphName}\" | ks_prepare | ks_calc_df`\nawait dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n    .then(ds => {\n\n        function processNode(node, line, usage) {\n            const nodeParamsMapping = {\n                \"start\": {\n                    \"res_P\": \"startP\",\n                    \"res_T\": \"startT\",\n                    \"res_Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"res_P\": \"endP\",\n                    \"res_T\": \"endT\",\n                    \"res_Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"res_velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n            };\n            let props = node.tag.properties;\n\n            if (\"junctionpoint\" === props.object_type.value){\n                return\n            }\n            //console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n            if (\n              \"start\" === usage ||\n              \"edge\" === usage ||\n              \"end\" === usage){\n                Object.entries(nodeParamsMapping[usage]).map(\n                  ([param,df]) => {\n                      //console.log(param)\n                      props[param].expression = line[df];\n                  })\n            }\n        }\n\n        function findNode(propertyWithID, columnWithID, line) {\n            let node = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (propertyWithID in node.tag.properties) {\n                    return Number(node.tag.properties[propertyWithID].expression) === Number(line[columnWithID])\n                } else {\n                    return false\n                }\n            })\n            //console.log(node)\n            return node\n        }\n\n        function processDfLine(line) {\n            let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n            if (null != sourceNode){\n                processNode(sourceNode, line, \"start\");\n            }\n            let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n            if (null != targetNode){\n                processNode(targetNode, line, \"end\");\n            }\n\n            let edgeNode = liveDashPanelWhatIf.masterGraph.nodes.find(node => {\n                if (\n                  'node_id_start' in node.tag.properties &&\n                  'node_id_end' in node.tag.properties) {\n                    return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.expression) &&\n                      Number(line.node_id_end) === Number(node.tag.properties.node_id_end.expression)\n                } else {\n                    return false;\n                }\n            });\n            if (null != edgeNode){\n                // console.log(\"process edgeNode\", edgeNode);\n                processNode(edgeNode, line, \"edge\");\n            }\n        };\n        //process result lines\n        Object.entries(ds).filter(([id, line]) => {\n                    return line['row_type'] === 'solution_result';\n                }).forEach(([id, line]) => {\n            let solution_result = line['value'];\n            console.log(customActionTitle, 'solution_result is ', solution_result);\n            \n            notificationSystem.create(customActionTitle, 'solution_result is ' + solution_result, notificationSettingsFail)})\n                })\n\n        Object.entries(ds).map(([id, line]) => {\n            processDfLine(line);\n        })\n\n        return true\n})\n    .then(t => {\n        liveDashPanelWhatIf.startCalculatingGraph()\n        notificationSystem.create(customActionTitle, \"Выполнен расчет по графу\", notificationSettingsSuccess)\n    })\n   .catch((e)=>{\n       console.log(\"Solver flow failed\")\n       console.log(e)\n       notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)})\n\nfunction getLongTableFromGraph(targetLiveDash) {\n    let table = [];\n    for (let node of targetLiveDash.masterGraph.nodes) {\n        let primitiveID = node.tag.primitiveID\n        let nodeName = node.tag.properties.Name.value\n\n        for (let prop in node.tag.properties) {\n            if (prop === \"Name\") {\n                continue\n            }\n            let line = {\n                \"primitiveID\": primitiveID,\n                \"nodeName\": nodeName,\n                \"nodeProperty\": prop,\n                \"value\": node.tag.properties[prop].value,\n            }\n            table.push(line)\n        }\n    }\n    return table\n}\n\nif (Application.autocomplete.WorkspaceSystem.tabsCollection.find(t => t.isActive).id === 'wss-tab-9078') {\n    let storageSystem = Application.autocomplete.StorageSystem\n\n    let tableFromWhatIf = getLongTableFromGraph(liveDashPanelWhatIf)\n\n    let experiments = storageSystem.session.getRecord(\"experiments\")\n\n    if (experiments && experiments.length !==0) {\n        experiments.push(tableFromWhatIf)\n    } else {\n        experiments = [tableFromWhatIf]\n    }\n\n    storageSystem.session.putRecord(\"experiments\", experiments)\n\n    let updatedTable = []\n\n    let tableExperiments = storageSystem.session.getRecord(\"expTable\")\n\n    for (let lineFromTable in tableExperiments) {\n        let lineFromCurrentExperiment = tableFromWhatIf.find(l => {return l.nodeName === tableExperiments[lineFromTable].nodeName && l.nodeProperty === tableExperiments[lineFromTable].nodeProperty})\n        let updatedLine = tableExperiments[lineFromTable]\n        updatedLine[`Experiment ${experiments.length}`] = lineFromCurrentExperiment.value\n        updatedTable.push(updatedLine)\n    }\n\n    storageSystem.session.putRecord(\"expTable\", updatedTable)\n}\n\nconsole.log(`Custom action \"${customActionTitle}\" finished`)"
    },
    {
        "name": "_v2MonitoringRefresh",
        "content": "let customActionTitle = \"Monitoring refresh\"\nconsole.log(`Custom action \"${customActionTitle}\" started`)\nlet workspaceSystem = Application.autocomplete.WorkspaceSystem\nlet liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\nlet liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\nlet dataSourceSystem = Application.autocomplete.DataSourceSystem\nlet notificationSystem = Application.autocomplete.NotificationSystem\nlet notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\nlet notificationSettingsFail = {type: \"error\", floatTime: 5, floatMode: true}\nlet notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\nasync function copyMonitoringGraphForSolver() {\n  let customActionTitle = \"function copyMonitoringGraphForSolver\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  let workspaceSystem = Application.autocomplete.WorkspaceSystem\n  let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\n  let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n\n  let tabMonitoring = \"wss-tab-5720\"\n  let tabWhatIf = \"wss-tab-9078\"\n\n  let notificationSystem = Application.autocomplete.NotificationSystem\n  let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n  let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n  let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n  let interactionSystem = Application.autocomplete.InteractionSystem\n\n  notificationSystem.create(customActionTitle, \"Подождите\", notificationSettingsInfo)\n\n  let usernamePromise = interactionSystem.GETRequest(\"/dtcd_utils/v1/user?username\").then(d => {return d.data.username})\n\n  let removeNodes = []\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n    removeNodes.push(node)\n  }\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return \"_remove_before_solver\" in node.tag.properties})) {\n    removeNodes.push(node)\n  }\n  for (let rn of removeNodes) {\n    liveDashPanelMonitoring.masterGraph.remove(rn)\n  }\n\n  for (const node_id in liveDashPanelMonitoring.nodes) {\n    let node = liveDashPanelMonitoring.nodes[node_id]\n    if (node_id.includes(\"DataLakeNode\")) {\n      delete node\n    } else {\n      for (const prop in node.tag.properties) {\n        if (typeof(node.tag.properties[prop].expression) === \"string\" && node.tag.properties[prop].expression !== \"\") {\n          node.tag.properties[prop].expression = JSON.stringify(node.tag.properties[prop].value)\n        } else {\n          node.tag.properties[prop].expression = node.tag.properties[prop].value\n        }\n      }\n    }\n  }\n  let username = await usernamePromise\n\n  let tmpGraphName = `${liveDashPanelMonitoring.graphMeta.graphName}_monitoring_${username}`\n\n  await interactionSystem.get(\"/supergraph/v1/fragments\").then(d => {\n    console.log(d)\n    let oldTmpFragments = d.data.fragments.filter(fr => {\n      return fr.name === tmpGraphName\n    })\n    for (let otf in oldTmpFragments) {\n      console.log(oldTmpFragments[otf])\n      interactionSystem.DELETERequest(`/supergraph/v1/fragments/${oldTmpFragments[otf].id}`)\n    }\n  })\n\n  await liveDashPanelMonitoring.saveAs({\"name\": tmpGraphName}).then( fragment => {\n      console.log(fragment)\n      let fr = {\"id\": liveDashPanelMonitoring.graphMeta.graphID, \"name\": liveDashPanelMonitoring.graphMeta.graphName}\n      console.log(fr)\n      liveDashPanelMonitoring.openFromServer(fr)\n    }\n  )\n  notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n  return tmpGraphName\n}\nasync function runSolver(tmpGraphName) {\n  let customActionTitle = \"Solver\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  let workspaceSystem = Application.autocomplete.WorkspaceSystem\n  let liveDashPanelMonitoring = Application.autocomplete.LiveDashPanel_2\n  let liveDashPanelWhatIf = Application.autocomplete.LiveDashPanel_3\n  let dataSourceSystem = Application.autocomplete.DataSourceSystem\n  let notificationSystem = Application.autocomplete.NotificationSystem\n  let notificationSettingsSuccess = {type: \"success\", floatTime: 5, floatMode: true}\n  let notificationSettingsFail = {type: \"fail\", floatTime: 5, floatMode: true}\n  let notificationSettingsInfo = {type: \"info\", floatTime: 5, floatMode: true}\n\n  notificationSystem.create(customActionTitle, \"Ожидайте окончания расчетов\", notificationSettingsInfo)\n  let solverOtl = `v2 | dtcd_read_graph \"${tmpGraphName}\" | ks_prepare | ks_calc_df`\n\n  await dataSourceSystem.oneShotRun(\"otl\", {cache_ttl: 5, queryString: solverOtl})\n  .then(ds => {\n\n    function processNode(node, line, usage) {\n      const nodeParamsMapping = {\n                \"start\": {\n                    \"res_P\": \"startP\",\n                    \"res_T\": \"startT\",\n                    \"res_Q_m3_day\": \"start_Q_m3_day\"\n                },\n                \"end\": {\n                    \"res_P\": \"endP\",\n                    \"res_T\": \"endT\",\n                    \"res_Q_m3_day\": \"end_Q_m3_day\"\n                },\n                \"edge\": {\n                    \"res_watercut_percent\": \"res_watercut_percent\",// Обводненность,TRUE\n                    \"res_liquid_density_kg_m3\": \"res_liquid_density_kg_m3\",// Плотность жидкости,\n                    \"res_pump_power_watt\": \"res_pump_power_watt\",// Мощность насоса,TRUE\n                    \"res_mass_flow_kg_sec\": \"X_kg_sec\",// Массовый поток,\n                    \"res_velocity_m_sec\": \"velocity_m_sec\"// Скорость потока,TRUE\n                }\n      };\n      let props = node.tag.properties;\n\n      if (\"junctionpoint\" === props.object_type.value){\n        return\n      }\n      console.log(\"eval \", usage, node.tag.primitiveID, props, line);\n      if (\n        \"start\" === usage ||\n        \"edge\" === usage ||\n        \"end\" === usage){\n        Object.entries(nodeParamsMapping[usage]).map(\n          ([param,df]) => {\n            props[param].expression = line[df];\n          })\n      }\n    }\n\n    function findNode(propertyWithID, columnWithID, line) {\n      let node = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n        if (propertyWithID in node.tag.properties) {\n          return Number(node.tag.properties[propertyWithID].value) === Number(line[columnWithID])\n        } else {\n          return false\n        }\n      })\n      console.log(node)\n      return node\n    }\n\n    function processDfLine(line) {\n      let sourceNode = findNode(\"node_id\", \"node_id_start\", line)\n      if (null != sourceNode){\n        processNode(sourceNode, line, \"start\");\n      }\n      let targetNode = findNode(\"node_id\", \"node_id_end\", line)\n      if (null != targetNode){\n        processNode(targetNode, line, \"end\");\n      }\n\n      let edgeNode = liveDashPanelMonitoring.masterGraph.nodes.find(node => {\n        if (\n          'node_id_start' in node.tag.properties &&\n          'node_id_end' in node.tag.properties) {\n          return Number(line.node_id_start) === Number(node.tag.properties.node_id_start.value) &&\n            Number(line.node_id_end) === Number(node.tag.properties.node_id_end.value)\n        } else {\n          return false;\n        }\n      });\n      if (null != edgeNode){\n        // console.log(\"process edgeNode\", edgeNode);\n        processNode(edgeNode, line, \"edge\");\n      }\n    };\n\n    Object.entries(ds).map(([id, line]) => {\n      processDfLine(line);\n    })\n\n    return true\n  })\n  .then(t => {\n    liveDashPanelMonitoring.startCalculatingGraph()\n    notificationSystem.create(customActionTitle, \"Готово\", notificationSettingsSuccess)\n  })\n  .catch((e)=>{\n    //console.log(\"Solver flow failed\")\n    console.log(\"Solver flow failed\", e);\n    notificationSystem.create(customActionTitle, \"Что-то пошло не так\", notificationSettingsFail)\n  })\n\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nasync function startCalculation() {\n  let customActionTitle = \"function startCalculation\"\n  console.log(`Custom action \"${customActionTitle}\" started`)\n  liveDashPanelMonitoring.startCalculatingGraph()\n  let dataLakeNodes = []\n  for (let node of liveDashPanelMonitoring.masterGraph.nodes.filter(node => {return node.tag.primitiveID.includes(\"DataLakeNode\")})) {\n    dataLakeNodes.push(node)\n  }\n  var completeCount = 0\n\n  while (completeCount != dataLakeNodes.length) {\n    for (let node of dataLakeNodes) {\n      if (node.tag.properties.query.status === \"complete\") {\n        completeCount += 1\n      }\n    }\n    await new Promise(r => setTimeout(r, 1000))\n  }\n\n  console.log(`Custom action \"${customActionTitle}\" finished`)\n}\n\nawait startCalculation()\nlet tmpGraphName = await copyMonitoringGraphForSolver()\nawait runSolver(tmpGraphName)"
    }
]