
# build_graph.py

no console arguments, run as is, config inside the code::

```py
config = ... # config io for graph generation
```

## require

- 'build_upon_loc': 'data/parent_tree_cut4_mod.json',
- 'node_templates_loc': './graph_builder/node_templates_no_img.json'
- initPortsTemplate: './graph_builder/initPorts.json'


write results to 
'write_to': 'result_graph_mod.json',


result_graph_mod.json - результирующий файл для датакада


## build_graph2.py

- ecn_to_ktpn_full3 - табличное представление списка объектов, строим дерево по таблице

- форматируем таблицу, выбираем колонки.
- выбираем колонки которые составят уникалльное имя - айди объекта для построения графа
- задаем соответствие свойств в таблице и свойств графа
- генерируем дерево связей

заадем расширение (плагин) откуда брать примитивы. если примитивы из разных наборов - указать отдельно
```py
extensionNameEl = "ExtensionElectricalSchemePrimitives"
```

Добавить примитивы в граф из таблицы (10 строк -> 10 нод).
указать колонки индекс, имя, сопоставить свойства из таблицы куда записать их в примитив.


```py
gmod.add_nodes_from_df(eu,
                       primitive_name_col="eu_primitiveName",
                       index_col="Электроустановка",
                       props_mapping=ee_props_mapping['Электроустановка'],
                       extensionName=extensionNameEl
                       )
```

поскольку у графа древовидная структура, в таблице для каждого примитива указываем родителя (parent_index_col), если рродитель существует то примитивы соединяются связью

```py
gmod.add_multiple_nodes(
    sh1,
    index_col=index_col,
    props_mapping=sh1_props_map,
    primitive_name_col="section_primitiveName",
    extensionName=extensionNameEl,
    parent_index_col=parent_index_col
    # edge_node_obj = edge_node_obj
)
```

Для моделирования неучтенных потребителей в граф добавили примитивы треугольник (вход/выход). Для каждой точки учета (куст) добавляем примитив если хотим показать невязку в этой точке.

```py
gmod.add_residuals(to_ktpn_df,
                    parent_name_col, parent_index_col,
                    props_mapping=residual_props_mapping)
```

т.е. после добавления кустов, тем же списком добавили другие примитивы.
Смысл такой конструкции:: сумма потребления скважин задается в примитивах скважин, на основе данных индекса или ручного ввода. Если есть несовпадение между данными из индекса по кусту и данными со скважин - есть какой-то еще потребитель в данной точке.

Вспомогательные примитивы (неучтенный потребитель) пока никак не используются при расчете графа.



## модификация сгенерированного графа

после генерации графа получаем лес (несколько несвязных деревьев) низкоуровневых объектов энергосети (скважина - ру - подстанция)

для сквозного моделирования, минимально необходимо знать источник питания объекта. далее это используется при расчете тарифа и т.д.

верхняя часть графа дорисовывалась руками. 
поскольку механизм генерации работает быстро а рисование руками - трудоемкий процесс, используем одну копию верхнего уровня сети, поверх генерируем остальные объекты. соединяем обе части графа связями.


соответствие какие объекты как соединять задается в начале  `build_graph2.py`, 

файл который используем за основу::
```py
    'build_upon': True,
    # 'build_upon_loc': 'data/top_graph_eu.json',
    # 'build_upon_loc': 'data/parent_tree_cut3 no_img.json',
    'build_upon_loc': 'data/parent_tree_cut4_mod.json',
```

чтобы связать обе части графа автоматически была написана таблица соответствие `data/mapping.csv`
```py
    # add link to parent nodes from top graph
    mapping = pd.read_csv('data/mapping.csv')

    mapping['this_node'] = mapping[index_col].apply(
        lambda name: gmod.get_node_by_name(name)
    )
    mapping['parentID'] = mapping['parentName'].apply(
        lambda name: gmod.get_node_by_name(name)
    )
    gmod.link_nodes_df(
        mapping,
        "this_node",
        'parentID',
        sourcePortId=0, targetPortId=0)
```

соответствие устанавливаем между айди/полными именами нод. (подставнция, ячейка, .... ->> потребитель.)

связей между частями графа не так много, но в данных от заказчика топологиии верхнего уровня в табличном виде нет.



## итог построения графа

в итоге получается дерево / несколько деревьев объектов энергосистемы.

реальная топология не полностью соответствует сети заказчика.
в общем случае, ВЛ могут работать в обе стороны (ненаправленные связи).
наша схема работает как дерево, все связи считаются односторонними.

датакад для оптимизации расстановки примитивов умеет работать с ненаправленными графами. 
расчет топологии и поиск источника тоже возможен (потенциально)

для расчета статического режима с направленными линиями, приходится создать дублирующие виртуальные связи (кто от кого может питаться)

Итого имеем граф:

- источники энергии
- потребители энергии
- входы/выходы
- вспомогательные неучтенные потребители
- связи == возможность направленной передачи энергии

граф направленный и древовидный.
возможен минимальный расчет средствами датакада(определение источника питания)

## расчет энергопотребления

сумма потребления дочерних потребителей - посчитать суммарный поток по графу.

реализовано средствами датакад, громоздко и невозможно поддерживать.

TODO:: реализовать команду постпроцессинга расчета энергетических метрик по графу аналогично с https://github.com/av-maltsev/pp_upstream/tree/master и https://github.com/ISGNeuroTeam/KirchhoffSolver

